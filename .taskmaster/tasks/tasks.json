{
  "master": {
    "tasks": [
      {
        "id": "1",
        "title": "현재 Pomobox 타이머 상태 관리 구조 분석 및 문서화",
        "description": "기존 타이머 상태(Focus/Break), 통계 계산 로직, 저장/복구 메커니즘을 분석하고 Pause 기능 구현을 위한 기초 이해도 확보",
        "details": "- 현재 타이머 상태 머신 구조 파악 (Focus/Short Break/Long Break 상태)\n- 세션 통계 계산 규칙 확인 (세션 증가, 완료 세션 증가, 누적 포커스 시간)\n- LocalStorage/SessionStorage 저장 정책 확인\n- Skip/Reset 동작의 현재 구현 방식 검토\n- 페이지 새로고침 시 상태 복구 로직 파악",
        "testStrategy": "코드 검토 및 문서화, 현재 타이머 동작 확인, 기존 통계 로직이 정상 작동하는지 검증",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "타이머 상태 머신 구조 및 상태 전환 로직 분석",
            "description": "현재 Pomobox에서 구현된 타이머 상태 머신(Focus/Short Break/Long Break)의 구조를 파악하고, 각 상태 간의 전환 로직을 체계적으로 분석하여 Pause 상태 추가를 위한 기초 이해도 확보",
            "dependencies": [],
            "details": "타이머 상태 관리 코드(useTimer, TimerState 등) 검토, 상태 머신 다이어그램 작성, 현재 상태 전환 규칙 문서화, Focus->Break->Focus 순환 구조 파악, 상태별 UI 렌더링 로직 확인\n<info added on 2025-12-24T08:41:57.028Z>\n```\n.taskmaster/docs/analysis-timer-state.md에 다음 내용을 문서화 완료:\n1. 현재 상태 머신: TimerType(focus/shortBreak/longBreak) + isRunning(boolean) 조합으로 상태 관리\n2. 통계 정책: Focus 타입이 00:00 도달 시에만 completedSessions/totalFocusMinutes 증가, Break는 통계 미반영\n3. 저장소 정책: localStorage에 설정(TimerSettings)과 통계(TimerStats)만 저장, 현재 타이머 상태(남은 시간/isRunning)는 미저장\n4. Skip/Reset 동작: Skip은 즉시 다음 타입 전환(통계 미반영), Reset은 현재 타입 초기 시간 복구\n5. Wall-clock 기반: setInterval(1000ms)로 1초 단위 카운트다운, 시스템 시간과 독립적\n6. Pause 추가 설계 방향 제안:\n   - phase(focus/break) + status(running/paused/idle) 분리로 상태 머신 개선\n   - localStorage 스키마 확장: pausedAt, remainingSeconds 필드 추가로 새로고침 복구 지원\n   - 00:00 경합 방지: isSessionComplete 플래그로 중복 완료 방지\n   - 통계 정책 불변: Pause/Resume은 세션 카운트/누적 시간에 영향 없음\n```\n</info added on 2025-12-24T08:41:57.028Z>",
            "status": "pending",
            "testStrategy": "코드 검토를 통해 상태 머신 구조 파악, 현재 타이머 UI에서 상태 전환 동작 확인, 기존 상태 전환이 정상 작동하는지 검증",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "통계 계산 로직(세션/완료 세션/누적 시간) 분석 및 저장소 정책 확인",
            "description": "세션 증가, 완료 세션 증가, 누적 포커스 시간 계산 규칙을 파악하고, LocalStorage/SessionStorage 저장 정책을 검토하여 Pause 기능이 통계를 훼손하지 않도록 설계하기 위한 기초 구성",
            "dependencies": [
              1
            ],
            "details": "통계 계산 함수(incrementSession, updateStats 등) 코드 검토, 각 통계 항목별 변경 시점 파악, LocalStorage vs SessionStorage 사용 정책 확인, 페이지 새로고침 시 통계 복구 로직 검토, 기존 통계 UI(대시보드) 표시 방식 분석",
            "status": "pending",
            "testStrategy": "코드 검토를 통해 통계 계산 규칙 문서화, 현재 대시보드에서 통계 수치 확인, Focus 세션 완료 시 통계 변경 검증",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Skip/Reset 동작 및 페이지 복구 로직 검토",
            "description": "현재 Skip 버튼과 Reset 버튼의 동작 방식을 분석하고, 페이지 새로고침 시 타이머 상태와 통계가 어떻게 복구되는지 파악하여 Pause 상태에서의 동작 방식 설계에 반영",
            "dependencies": [
              1
            ],
            "details": "Skip 버튼 클릭 시 상태 전환 흐름 분석, Reset 버튼 클릭 시 상태/통계 초기화 로직 검토, 페이지 새로고침 시 SessionStorage/LocalStorage에서 상태 복구하는 방식 파악, Skip/Reset 중 통계 변경 여부 확인, 타이머 인터벌 정리 로직 검토",
            "status": "pending",
            "testStrategy": "코드 검토를 통해 Skip/Reset 동작 문서화, 실제 UI에서 Skip/Reset 버튼 클릭 시 동작 확인, 페이지 새로고침 후 타이머 상태 복구 검증",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Pause 상태를 포함한 상태 머신 설계 및 상태 전환 규칙 정의",
            "description": "분석 결과를 바탕으로 Pause 상태를 기존 상태 머신에 통합하고, Pause 진입/복귀 조건, Skip/Reset 동작, 통계 정책을 명시한 상태 전환 규칙을 설계하여 구현 기초 마련",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "확장된 상태 머신 다이어그램 작성(Focus->Pause->Focus, Break->Pause->Break 경로), Pause 상태 진입 조건(Focus/Short Break/Long Break에서만 가능), Resume 조건(Pause에서만 가능), Pause 상태에서 Skip/Reset 버튼 동작 정의, Pause/Resume 중 통계 변경 금지 규칙 명시, 페이지 새로고침 시 Pause 상태 복구 로직 정의, 기술 설계 문서(Design Document) 작성",
            "status": "pending",
            "testStrategy": "상태 전환 테스트 케이스 설계(모든 상태에서 Pause 가능 여부, Pause->Resume 경로, 통계 변경 없음, Skip/Reset 시 동작), 설계 문서 리뷰를 통한 로직 검증",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Pause 기능 구현 및 통합 검증",
            "description": "설계된 상태 머신을 바탕으로 Pause 상태 처리를 카운트다운 로직에 구현하고, 기존 통계 계산과의 호환성을 검증하여 최종 빌드/린트/테스트를 통과시키는 완성 단계",
            "dependencies": [
              4
            ],
            "details": "카운트다운 루프에 Pause 상태 체크 추가(if (state === 'Pause') return), remainingTime 저장/복구 로직 구현, 00:00 근처에서의 중복 완료 처리 방지, Pause/Resume UI 버튼 추가 및 이벤트 핸들러 연결, 통계 계산 로직이 Pause 중 변경되지 않는지 검증, 페이지 새로고침 시 Pause 상태 복구 로직 구현, pnpm lint/build/test 실행 및 오류 해결, 브라우저 호환성 확인, 최종 코드 리뷰 및 문서화",
            "status": "pending",
            "testStrategy": "카운트다운 시뮬레이션 테스트(Pause 전후 시간 값 비교, 시간 감소 정지 확인), 통계 변경 없음 검증(여러 Pause/Resume 시나리오), 자동화된 빌드/린트/테스트 파이프라인 실행, E2E 테스트로 UI 흐름 검증, 기존 타이머 기능 정상 작동 확인",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "타이머 상태 머신 구조 파악 (Focus/Short Break/Long Break 상태)",
            "description": "현재 코드에서 타이머가 Focus, Short Break, Long Break 상태를 어떻게 정의하고 전환하는지 분석합니다.",
            "dependencies": [],
            "details": "src/components/Timer.tsx (또는 관련 파일)에서 상태 타입 정의, 상태 전환 조건, 각 상태별 타이머 지속 시간 설정을 검토합니다. 상태 전환 시점(완료/Skip/Reset)과 상태 변수 저장 위치를 확인하고, 상태 머신 다이어그램 초안을 작성합니다.",
            "status": "pending",
            "testStrategy": "코드 검토 및 상태 전환 시나리오를 콘솔 로그로 확인, 각 상태별 타이머 동작이 예상대로 이루어지는지 수동 테스트",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "세션 통계 계산 규칙 확인 (세션 증가, 완료 세션 증가, 누적 포커스 시간)",
            "description": "타이머 완료 시 세션 카운트, 완료 세션 카운트, 누적 포커스 시간이 어떻게 계산되고 업데이트되는지 분석합니다.",
            "dependencies": [
              6
            ],
            "details": "통계 관련 상태 변수(예: sessionCount, completedSessions, totalFocusTime)를 찾고, Focus 완료 시/Break 완료 시/Skip 시/Reset 시 각각 통계가 어떻게 변경되는지 로직을 추적합니다. 통계 업데이트 함수의 호출 시점과 조건을 문서화하고, Pause 기능 추가 시 통계에 영향을 주지 않도록 할 영역을 명시합니다.",
            "status": "pending",
            "testStrategy": "타이머 완료/Skip/Reset 동작 후 통계 값 변화를 확인, 예상 통계 값과 실제 값 비교, 기존 통계 로직이 정상 작동하는지 검증",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "LocalStorage/SessionStorage 저장 정책 확인",
            "description": "타이머 상태와 통계가 LocalStorage 또는 SessionStorage에 어떻게 저장되고 복구되는지 분석합니다.",
            "dependencies": [
              6
            ],
            "details": "저장 키 이름, 저장 시점(상태 변경 시/완료 시/주기적 저장), 저장 데이터 구조(JSON 스키마)를 확인합니다. Pause 상태 추가 시 저장해야 할 추가 필드(예: isPaused, remainingTime)를 식별하고, 저장 정책 문서를 작성합니다.",
            "status": "pending",
            "testStrategy": "브라우저 개발자 도구에서 Application > Storage 탭으로 저장된 데이터 확인, 타이머 동작 후 저장 값 변화 추적, 수동으로 저장 값 변경 후 복구 동작 확인",
            "parentId": "undefined"
          },
          {
            "id": 9,
            "title": "Skip/Reset 동작의 현재 구현 방식 검토",
            "description": "Skip 버튼과 Reset 버튼 클릭 시 타이머와 통계가 어떻게 처리되는지 분석합니다.",
            "dependencies": [
              6,
              7
            ],
            "details": "Skip 핸들러와 Reset 핸들러의 코드를 검토하여, 각각 상태 전환, 통계 업데이트, 저장소 업데이트를 어떻게 수행하는지 파악합니다. Pause 상태에서 Skip/Reset을 허용할지 여부를 결정하기 위해 현재 동작을 문서화하고, Pause 상태 추가 시 Skip/Reset 로직 수정 범위를 명시합니다.",
            "status": "pending",
            "testStrategy": "각 상태에서 Skip/Reset 버튼 클릭 후 상태 및 통계 변화 확인, 예상 동작과 실제 동작 비교, 코드 리뷰로 로직 검증",
            "parentId": "undefined"
          },
          {
            "id": 10,
            "title": "페이지 새로고침 시 상태 복구 로직 파악",
            "description": "페이지 새로고침 또는 재진입 시 저장된 타이머 상태와 통계를 어떻게 복구하는지 분석합니다.",
            "dependencies": [
              8
            ],
            "details": "컴포넌트 마운트 시점에 LocalStorage/SessionStorage에서 상태를 읽어오는 로직을 찾고, 복구 조건(타이머 진행 중/완료/초기 상태)과 복구 우선순위를 확인합니다. Pause 상태 복구 시나리오(새로고침 시 Pause 상태 유지)를 설계하기 위해 현재 복구 경로를 문서화합니다.",
            "status": "pending",
            "testStrategy": "타이머 진행 중 페이지 새로고침 후 상태 복구 확인, Pause 상태(미래 구현) 복구 시나리오 시뮬레이션, 복구 로직 코드 리뷰 및 동작 검증",
            "parentId": "undefined"
          }
        ],
        "complexity": 3,
        "recommendedSubtasks": 5,
        "expansionPrompt": "타이머 상태 머신(focus/break/longBreak), 통계 계산 규칙(세션/완료/누적시간), localStorage 저장 정책, Skip/Reset 동작, 페이지 복구 로직을 각각 상세 분석하고 문서화하는 서브태스크로 확장하세요. 코드 검토와 동작 확인이 주 목적입니다.",
        "updatedAt": "2025-12-24T08:47:36.885Z"
      },
      {
        "id": "2",
        "title": "Pause 상태를 포함한 타이머 상태 머신 설계",
        "description": "기존 상태(Focus/Break)에 Pause 상태를 추가하고, 상태 전환 규칙을 정의하여 통계 정책이 깨지지 않도록 설계",
        "details": "- 상태 머신 다이어그램 작성 (Focus -> Pause -> Focus -> Complete / Break -> Pause -> Break -> Complete)\n- Pause 상태 진입 조건: Focus/Short Break/Long Break 중에만 가능\n- Resume 조건: Pause 상태에서만 가능\n- Pause 상태에서 Skip/Reset 버튼 동작 정의 (즉시 다음 상태로 전환)\n- 통계 변경 금지 영역 명시 (Pause/Resume은 세션 카운트, 완료 시간에 영향 없음)\n- 페이지 새로고침 시 Pause 상태 복구 경로 정의",
        "testStrategy": "상태 전환 테스트 케이스 작성 (모든 상태에서 Pause 가능 여부, Pause->Resume->Complete 시나리오, 통계 변경 없음 확인)",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "기존 상태 머신 구조 분석 및 Pause 진입/복귀 경로 정의",
            "description": "현재 타이머의 Focus/Short Break/Long Break 상태 구조를 분석하고, Pause 상태가 어느 상태에서 진입 가능한지, 어느 상태로 복귀할 수 있는지 명확히 정의",
            "dependencies": [],
            "details": "기존 상태 머신 다이어그램 검토 → Focus/Short Break/Long Break에서 Pause 진입 가능 → Pause에서 원래 상태로만 복귀 가능 → 상태 진입/복귀 규칙 문서화 → 코드에서 현재 상태 저장 메커니즘 확인",
            "status": "pending",
            "testStrategy": "상태 전환 로직 검토, 진입 조건과 복귀 경로가 일관성 있게 정의되었는지 확인",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "모든 상태 전환 경로를 포함한 상태 머신 다이어그램 작성",
            "description": "Focus → Pause → Focus, Break → Pause → Break, Complete 등 모든 가능한 상태 전환 경로를 시각화한 다이어그램 작성 및 문서화",
            "dependencies": [
              1
            ],
            "details": "다이어그램 포맷 결정 (Mermaid, SVG, 텍스트) → 모든 정상 경로 표시 (Focus→Complete, Break→Complete) → Pause 진입 조건 표시 → Pause에서 Skip/Reset 시 다음 상태로 직접 전환 경로 표시 → 엣지 케이스 경로 포함 (새로고침 후 복구) → 최종 다이어그램 검토 및 승인",
            "status": "pending",
            "testStrategy": "다이어그램이 모든 가능한 상태 전환을 포함하는지 검증, 순환 참조나 불가능한 경로 없는지 확인",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Pause 상태 고유 조건 및 Resume/Skip/Reset 동작 정의",
            "description": "Pause 진입 가능 상태, Resume만 Pause에서 가능, Pause 중 Skip/Reset 동작 방식을 명확히 정의하고 코드 레벨 구현 기준 수립",
            "dependencies": [
              2
            ],
            "details": "Pause 진입 조건: Focus/Short Break/Long Break에서만 가능 (Complete 상태에서는 불가) → Resume 조건: Pause 상태에서만 실행 가능 → Skip 동작: Pause 중 Skip 클릭 시 Pause 해제 후 즉시 Complete 상태로 전환 → Reset 동작: Pause 중 Reset 시 원래 상태로 돌아가고 시간 초기화 → 각 동작의 코드 구현 포인트 정리",
            "status": "pending",
            "testStrategy": "각 상태에서 Resume 시도 시 실패 확인, Pause 상태에서만 Resume 성공, Skip/Reset의 상태 전환이 정확한지 검증",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "통계 변경 금지 규칙 명확화 (Pause/Resume 무영향 정책)",
            "description": "Pause/Resume 조작 시 세션 카운트, 완료 시간, 누적 포커스 시간이 변경되지 않도록 정책 수립 및 문서화",
            "dependencies": [
              3
            ],
            "details": "변경 금지 통계 항목: 세션 카운트 (Focus 시작 시에만 증가), 완료 세션 (완료 시점에만 증가), 누적 포커스 시간 (완료 시점에만 누적) → Pause 중 발생하는 시간은 타이머 계산에서 제외 → Skip 시 해당 세션 완료 처리 (통계 증가) → Reset 시 세션 미완료 처리 (통계 미변경) → 이벤트 로깅: Pause/Resume 액션은 기록하되 통계에는 미반영 → 정책 문서 작성",
            "status": "pending",
            "testStrategy": "Pause/Resume 전후 통계 값이 동일한지 확인, Skip/Reset 시 통계 변경이 정책대로 적용되는지 검증",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "페이지 새로고침 시 Pause 상태 복구 흐름 정의",
            "description": "사용자가 Pause 상태에서 페이지를 새로고침했을 때 Pause 상태가 정확히 복구되는 메커니즘 설계 및 구현 경로 명시",
            "dependencies": [
              4
            ],
            "details": "LocalStorage/SessionStorage에 Pause 상태 저장 (isPaused=true, pausedState='Focus' 등) → 페이지 로드 시 저장된 Pause 상태 조회 → Pause 상태 복구 시 타이머 일시정지 상태 유지 → 저장된 경과 시간 복구하여 Resume 시 정확한 시간부터 재개 → 새로고침 전후 통계 일관성 유지 → Pause 상태 복구 실패 시 fallback 정책 (안전한 상태로 전환)",
            "status": "pending",
            "testStrategy": "Pause 상태에서 새로고침 후 상태 정확히 복구 확인, 경과 시간이 올바르게 유지되는지 검증, 통계 손실 없는지 확인",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "상태 머신 설계 문서 완성 및 구현 가능성 검토",
            "description": "위 5개 단계의 결과를 통합하여 최종 상태 머신 설계 문서를 작성하고, 기존 코드베이스와의 호환성 및 구현 복잡도 검토",
            "dependencies": [
              5
            ],
            "details": "상태 머신 다이어그램 최종 버전 통합 → 모든 상태, 전환, 조건을 명시한 통합 문서 작성 (마크다운/다이어그램) → 구현 가능성 검토: 현재 코드 구조에 Pause 상태 추가 가능성 확인 → 엣지 케이스 검토: 네트워크 끊김, 브라우저 탭 전환, 다중 태브 동시 실행 등 고려 → 기존 테스트 정책과의 충돌 검토 → 성능/메모리 영향 분석 (Pause 상태 저장/복구 오버헤드) → 최종 승인 및 구현 시작 체크리스트 작성",
            "status": "pending",
            "testStrategy": "설계 문서가 모든 요구사항을 포함하는지 검증, 구현 팀이 문서 기반으로 일시성 있게 구현할 수 있는지 검토, 누락된 엣지 케이스 없는지 최종 점검",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 6,
        "expansionPrompt": "기존 3가지 상태에 Pause 상태를 추가하는 상태 머신 설계를 다음으로 나누세요: (1) 기존 상태 구조 분석 및 Pause 진입/복귀 경로 정의, (2) 상태 다이어그램 작성, (3) Pause 상태 고유 조건 및 Resume/Skip/Reset 동작 정의, (4) 통계 변경 금지 규칙 명확화, (5) 페이지 새로고침 시 복구 흐름 정의, (6) 설계 문서 완성 및 검토",
        "updatedAt": "2025-12-24T08:50:39.703Z"
      },
      {
        "id": "3",
        "title": "타이머 카운트다운 로직에서 Pause 상태 처리 구현",
        "description": "setInterval/setTimeout 기반 카운트다운을 수정하여 Pause 상태에서 시간 감소가 멈추도록 구현",
        "details": "- 카운트다운 루프 조건에 상태 체크 추가: if (state === 'Pause') return; // 시간 감소 안 함\n- Pause 상태 진입 시 이전 남은 시간(remainingTime) 저장\n- Resume 시 저장된 remainingTime부터 재개\n- 타이머 인터벌 유지 (기존 인터벌 해제/재설정 여부 결정)\n- 00:00 도달 직전 Pause/Resume 연타 시 중복 완료 처리 방지 로직 추가 (플래그/뮤텍스 패턴)\n- 기존 카운트다운 테스트가 여전히 통과하는지 확인",
        "testStrategy": "카운트다운 시뮬레이션 테스트 (Pause 전후 시간 값 비교, 시간 감소 정지 확인, 00:00 근처에서의 중복 완료 방지 검증)",
        "priority": "high",
        "dependencies": [
          "2"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "기존 카운트다운 구조 파악 및 상태 관리 분석",
            "description": "현재 setInterval/setTimeout 기반 카운트다운 로직을 분석하고, 상태(Focus/Break) 관리 구조를 파악하여 Pause 구현 기반 마련",
            "dependencies": [],
            "details": "- src 디렉토리에서 타이머 카운트다운 로직 파일 위치 확인\n- setInterval/setTimeout 사용 방식 분석\n- 현재 상태 머신 구조(Focus/Short Break/Long Break) 파악\n- remainingTime 저장/업데이트 메커니즘 확인\n- 기존 테스트 파일 검토 (테스트 케이스 이해)\n- 문서/주석으로 구조 정리",
            "status": "done",
            "testStrategy": "코드 리뷰 및 문서화 검증, 기존 타이머 동작 수동 테스트",
            "parentId": "undefined",
            "updatedAt": "2025-12-24T14:19:07.585Z"
          },
          {
            "id": 2,
            "title": "Pause 상태 진입 시 remainingTime 저장 메커니즘 구현",
            "description": "Pause 버튼 클릭 또는 상태 전환 시 현재 remainingTime을 별도 변수에 저장하여 Resume 시 재사용할 수 있도록 구현",
            "dependencies": [
              1
            ],
            "details": "- pausedTime 변수 추가 (Pause 시점의 remainingTime 저장용)\n- Pause 상태 진입 로직에서 pausedTime = remainingTime 할당\n- 상태 저장 시 pausedTime도 함께 저장 (LocalStorage/SessionStorage)\n- Resume/Skip/Reset 등 다른 상태 전환 시 pausedTime 초기화 로직\n- Edge case: Pause 상태에서 페이지 새로고침 후 복구 시 pausedTime 활용",
            "status": "done",
            "testStrategy": "Pause 상태 진입 전후 remainingTime 값 비교, 저장된 pausedTime 확인, 페이지 새로고침 후 복구 검증",
            "parentId": "undefined",
            "updatedAt": "2025-12-24T14:19:07.588Z"
          },
          {
            "id": 3,
            "title": "카운트다운 루프에 Pause 상태 체크 조건 추가",
            "description": "setInterval/setTimeout 기반 카운트다운 루프 내에 상태 체크를 추가하여 Pause 상태에서는 시간 감소가 멈추도록 구현",
            "dependencies": [
              1
            ],
            "details": "- 카운트다운 루프(setInterval 콜백 등) 상단에 if (state === 'Pause') return; 조건 추가\n- 또는 Pause 상태에서는 setInterval 자체를 clearInterval로 정지하는 방식 검토\n- Pause 상태에서 카운트다운 증감이 0이 되도록 보장\n- remainingTime 업데이트 로직이 Pause 상태를 정확히 무시하는지 확인\n- 기존 카운트다운 정확도(밀리초 단위) 유지 여부 검증",
            "status": "done",
            "testStrategy": "Pause 상태 진입 후 시간 증감 중단 확인, 일정 시간 경과 후 remainingTime 변화 없음 검증, 기존 정확도 테스트 통과",
            "parentId": "undefined",
            "updatedAt": "2025-12-24T14:19:07.591Z"
          },
          {
            "id": 4,
            "title": "Resume 시 저장된 remainingTime부터 재개 로직 구현",
            "description": "Resume 상태로 전환할 때 Pause 중에 저장된 pausedTime을 remainingTime으로 복구하고 카운트다운을 재개하는 로직 구현",
            "dependencies": [
              2,
              3
            ],
            "details": "- Resume 상태 진입 시 remainingTime = pausedTime 복구\n- setInterval 재시작 (이전에 clearInterval한 경우) 또는 상태 플래그만 변경\n- 카운트다운이 정확하게 이어지는지 확인 (시간 점프 없음)\n- pausedTime 초기화 (다음 Pause 대비)\n- Focus/Break 상태 복구 (Pause 전 상태로)\n- 상태 저장 (LocalStorage/SessionStorage)",
            "status": "done",
            "testStrategy": "Pause 후 Resume 시 시간이 정확히 이어지는지 확인, 상태 복구 검증, 여러 번 Pause/Resume 반복 후 정확도 유지 확인",
            "parentId": "undefined",
            "updatedAt": "2025-12-24T14:19:07.593Z"
          },
          {
            "id": 5,
            "title": "00:00 도달 직전 Pause/Resume 연타 시 중복 완료 방지 로직 추가",
            "description": "00:00에 근접한 상태에서 Pause/Resume을 빠르게 반복할 때 완료(onComplete) 콜백이 중복 호출되지 않도록 플래그/뮤텍스 패턴으로 보호",
            "dependencies": [
              3,
              4
            ],
            "details": "- isCompleting 또는 hasCompleted 플래그 추가 (초기값: false)\n- 카운트다운이 0 이하가 되고 상태 전환 시 플래그를 true로 설정\n- onComplete() 콜백 호출 전 플래그 확인 (이미 true면 중복 호출 방지)\n- Pause/Resume 중 플래그 변경 금지\n- Skip/Reset 시 플래그 초기화\n- Focus 새 세션 시작 시 플래그 초기화\n- 플래그 상태를 LocalStorage/SessionStorage에 저장",
            "status": "done",
            "testStrategy": "00:00 근처에서 Pause/Resume 빠른 반복 시 onComplete 단일 호출 확인, 로그/이벤트 추적으로 중복 호출 방지 검증",
            "parentId": "undefined",
            "updatedAt": "2025-12-24T14:19:07.596Z"
          },
          {
            "id": 6,
            "title": "기존 카운트다운 테스트 호환성 검증",
            "description": "Pause 기능 추가 후 기존에 작성된 모든 카운트다운 테스트가 여전히 통과하는지 확인하고, 실패하는 경우 원인 분석 및 수정",
            "dependencies": [
              2,
              3,
              4,
              5
            ],
            "details": "- 기존 테스트 파일(*.test.js, *.spec.js 등) 실행 (pnpm test)\n- 각 테스트 케이스 검토 (Focus 완료, Break 완료, Skip, Reset 등)\n- Pause 로직으로 인한 부작용 확인 (상태 전환, 시간 감소 등)\n- 실패한 테스트 원인 파악 및 수정\n- 새 Pause/Resume 관련 테스트 케이스 추가 (선택사항)\n- 테스트 커버리지 확인",
            "status": "done",
            "testStrategy": "pnpm test 실행, 모든 테스트 통과 확인, 실패 시 원인 분석 및 수정, 테스트 커버리지 리포트 검토",
            "parentId": "undefined",
            "updatedAt": "2025-12-24T14:19:07.599Z"
          },
          {
            "id": 7,
            "title": "빌드/린트 실행 및 최종 품질 검증",
            "description": "Pause 기능 완성 후 pnpm lint와 pnpm build를 실행하여 코드 스타일, 타입 오류, 번들 생성 오류를 최종 검증",
            "dependencies": [
              6
            ],
            "details": "- pnpm lint 실행: 코드 스타일, ESLint 규칙 확인, 미사용 변수/임포트 제거\n- pnpm build 실행: 번들 생성, 빌드 오류/경고 확인\n- 타입스크립트 타입 오류 확인 (있는 경우)\n- 모든 경고 메시지 해결\n- 커밋 전 최종 코드 리뷰: 주석, 문서화, 일관성 확인\n- 브라우저에서 타이머/Pause 동작 수동 테스트 (개발 환경)",
            "status": "done",
            "testStrategy": "pnpm lint 및 pnpm build 성공, 모든 오류/경고 0, 개발 환경에서 브라우저 수동 테스트, 최종 코드 리뷰 체크리스트 확인",
            "parentId": "undefined",
            "updatedAt": "2025-12-24T14:19:07.602Z"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 7,
        "expansionPrompt": "카운트다운 로직 수정을 다음으로 세분화하세요: (1) 기존 wall-clock 기반 카운트다운 구조 파악, (2) Pause 시 remainingTime 저장 메커니즘, (3) 카운트다운 루프에 Pause 체크 조건 추가, (4) Resume 시 저장된 시간부터 재개, (5) 00:00 도달 직전 중복 완료 방지 플래그, (6) 기존 테스트 호환성 검증, (7) 빌드/린트 실행",
        "updatedAt": "2025-12-24T14:19:07.602Z"
      },
      {
        "id": "4",
        "title": "UI에서 Pause/Resume 버튼 노출 및 상태 표시",
        "description": "타이머 UI에 Pause/Resume 버튼을 조건부로 노출하고, Pause 상태일 때 시각적 표시(예: '일시정지' 텍스트/배경색)를 추가",
        "details": "- Focus/Short Break/Long Break 상태에서만 Pause 버튼 표시\n- Pause 상태에서 Pause 버튼을 Resume 버튼으로 변경 (또는 토글)\n- 타이머 UI 패널에 '일시정지' 상태 텍스트 또는 배경색 변경 (예: 회색 배경, 'PAUSED' 라벨)\n- 시간 표시는 유지 (Pause 중에도 남은 시간 표시)\n- 반응형 디자인 확인 (모바일/데스크톱)\n- 기존 타이머 UI 스타일과 일관성 유지",
        "testStrategy": "각 상태별 UI 렌더링 테스트 (Focus 중 Pause 버튼 표시, Pause 중 Resume 버튼 표시, '일시정지' 레이블 확인, 버튼 클릭 반응성)",
        "priority": "medium",
        "dependencies": [
          "2"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Pause/Resume 버튼 조건부 렌더링 구현",
            "description": "Focus/Short Break/Long Break 상태에서만 Pause 버튼을 표시하고, Pause 상태에서 Resume 버튼으로 토글하는 조건부 렌더링 로직 구현",
            "dependencies": [],
            "details": "타이머 UI 컴포넌트에서 현재 state(Focus/Short Break/Long Break/Pause)를 확인하여 Pause 버튼의 표시 여부를 결정합니다. Pause 상태일 때는 버튼 텍스트와 클릭 핸들러를 Resume으로 변경합니다. 기존 Skip/Reset 버튼과 함께 배치되도록 UI 레이아웃을 조정합니다.",
            "status": "pending",
            "testStrategy": "각 상태별로 Pause 버튼의 표시 여부를 확인(Focus 상태: 표시, Pause 상태: Resume으로 표시, Ready/Break 완료 상태: 미표시)",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "일시정지 상태 시각적 표시 추가",
            "description": "타이머 UI 패널에 Pause 상태일 때 시각적 피드백(배경색 변경, '일시정지' 또는 'PAUSED' 레이블 추가)을 구현",
            "dependencies": [
              1
            ],
            "details": "Pause 상태 진입 시 타이머 패널의 배경색을 회색 또는 다른 색상으로 변경하고, '일시정지' 또는 'PAUSED' 텍스트 레이블을 추가합니다. 남은 시간 표시는 유지되며, 모바일/데스크톱 레이아웃에서 일관되게 표시됩니다. 기존 타이머 UI 스타일과의 일관성을 유지합니다.",
            "status": "pending",
            "testStrategy": "Pause 상태에서 배경색 변경 확인, '일시정지' 레이블 표시 확인, 시간 표시 정상 동작 확인, 반응형 레이아웃 검증(모바일 480px, 태블릿 768px, 데스크톱 1024px)",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "타이머 카운트다운 로직에 Pause 상태 처리 추가",
            "description": "setInterval/setTimeout 기반 카운트다운에서 Pause 상태일 때 시간 감소가 멈추도록 구현하고, Resume 시 저장된 시간부터 재개",
            "dependencies": [
              2
            ],
            "details": "카운트다운 루프의 조건문에 상태 체크(if (state === 'Pause') return)를 추가하여 시간 감소를 정지합니다. Pause 진입 시 remainingTime을 저장하고, Resume 시 저장된 값부터 재개합니다. 00:00 도달 직전에 Pause/Resume 연타 시 중복 완료를 방지하기 위해 isSessionComplete 플래그를 추가합니다.",
            "status": "pending",
            "testStrategy": "Pause 전후의 remainingTime 값 비교(같아야 함), 시간 감소 정지 확인(1초 경과 후에도 시간 변화 없음), 00:01에서 Pause/Resume 연타 후 완료 처리 1회만 수행 확인",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Pause/Resume 버튼 클릭 핸들러 구현",
            "description": "Pause 버튼 클릭 시 상태 전환, remainingTime 저장 및 카운트다운 정지 신호 전송, Resume 클릭 시 상태 복구 및 카운트다운 재개 로직 구현",
            "dependencies": [
              3
            ],
            "details": "Pause 핸들러: state를 'Pause'로 변경, currentTime/remainingTime 저장, 카운트다운 인터벌 제어. Resume 핸들러: 이전 state(Focus/Short Break/Long Break)로 복구, 저장된 remainingTime부터 카운트다운 재개. 디바운싱(300ms)을 적용하여 중복 클릭 방지. LocalStorage에 상태 저장. Skip/Reset 핸들러와의 간섭 확인.",
            "status": "pending",
            "testStrategy": "Pause 클릭 후 state 변경 확인, remainingTime 저장 확인, Resume 클릭 후 카운트다운 재개 확인, 중복 클릭 방지(300ms 내 클릭 무시) 검증, LocalStorage 저장 확인",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "반응형 디자인 및 스타일 일관성 검증",
            "description": "모바일/태블릿/데스크톱 레이아웃에서 Pause/Resume 버튼과 일시정지 상태 표시가 정상 작동하는지 확인하고 기존 스타일과 일관성 유지",
            "dependencies": [
              2,
              4
            ],
            "details": "각 화면 크기(모바일 480px, 태블릿 768px, 데스크톱 1024px 이상)에서 버튼 배치, 텍스트 크기, 배경색 변경이 정상적으로 표시되는지 확인합니다. 기존 타이머 UI의 폰트, 간격, 색상과의 일관성을 유지합니다. 터치 인터페이스(모바일)에서 버튼 클릭 용이성을 확인합니다.",
            "status": "pending",
            "testStrategy": "Chrome DevTools 반응형 디자인 모드에서 각 화면 크기별 UI 렌더링 확인, 버튼 클릭 가능성 검증, 기존 타이머 스타일과 색상/폰트 일관성 검증",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Pause/Resume 기능 통합 테스트 및 에지 케이스 처리",
            "description": "전체 Pause/Resume 기능이 정상 작동하는지 통합 테스트하고, 00:00 도달 시점의 중복 완료, 빠른 상태 전환 등 엣지 케이스 검증",
            "dependencies": [
              3,
              4,
              5
            ],
            "details": "통합 테스트: Focus 상태 → Pause → Resume → 정상 계속 진행, 여러 번의 Pause/Resume 반복 시 상태 정상 유지, 00:01에서 Pause/Resume 연타 시 세션 완료 1회만 수행, isSessionComplete 플래그 검증. 페이지 새로고침 시 Pause 상태 복구 확인. Skip/Reset과의 상호작용 검증. 통계 중복 증가 방지 확인.",
            "status": "pending",
            "testStrategy": "시나리오 기반 테스트: (1) Focus 진행 중 Pause → 시간 정지, (2) Resume → 시간 재개, (3) 00:01에서 Pause/Resume 연타 → 완료 1회만, (4) 페이지 새로고침 후 Pause 상태 유지 확인, (5) Skip/Reset 클릭 시 Pause 상태 정상 종료",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 6,
        "expansionPrompt": "UI 구현을 다음으로 나누세요: (1) Pause/Resume 버튼 조건부 렌더링(상태별), (2) Pause 상태 시각적 표시(배경색, 레이블), (3) 타이머 카운트다운 로직에 Pause 처리 추가, (4) Pause/Resume 버튼 클릭 핸들러, (5) 반응형 디자인 및 스타일 일관성 검증, (6) 통합 테스트 및 엣지 케이스 처리",
        "updatedAt": "2025-12-24T11:28:43.115Z"
      },
      {
        "id": "5",
        "title": "Pause/Resume 버튼 클릭 이벤트 핸들러 구현",
        "description": "Pause/Resume 버튼 클릭 시 상태 전환 및 관련 로직(카운트다운 정지/재개, 상태 저장)을 처리하는 핸들러 구현",
        "details": "- Pause 버튼 클릭 핸들러: state = 'Pause', remainingTime 저장, 카운트다운 정지 신호 전송\n- Resume 버튼 클릭 핸들러: state 복구 (Focus/Break), 카운트다운 재개\n- 각 핸들러에서 상태 변경 후 상태 저장 (LocalStorage/SessionStorage)\n- 디바운싱/쓰로틀링 적용 (중복 클릭 방지)\n- 버튼 비활성화 상태 관리 (Pause 전환 중에 중복 클릭 방지)\n- 기존 Skip/Reset 핸들러와의 간섭 확인",
        "testStrategy": "버튼 클릭 시뮬레이션 테스트 (Pause 클릭 후 상태 변경 확인, 저장 확인, Resume 클릭 후 재개 확인, 중복 클릭 방지 동작)",
        "priority": "high",
        "dependencies": [
          "3",
          "4"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Pause 버튼 클릭 핸들러 구현",
            "description": "Pause 버튼 클릭 시 상태를 'Pause'로 전환하고 남은 시간을 저장한 후 카운트다운 정지 신호를 전송하는 핸들러 구현",
            "dependencies": [],
            "details": "handlePauseClick 함수를 구현하여 현재 상태(Focus/Break)를 이전 상태로 저장하고, state를 'Pause'로 변경하며, remainingTime을 추출하여 저장한 후, 카운트다운 타이머를 중단하는 신호를 발생시킨다. 상태 변경 후 LocalStorage에 저장한다.",
            "status": "pending",
            "testStrategy": "Pause 상태 진입 테스트: Focus/Break 상태에서 Pause 버튼 클릭 후 state === 'Pause' 확인, remainingTime이 정확히 저장되었는지 검증, 카운트다운이 정지되었는지 확인",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Resume 버튼 클릭 핸들러 구현",
            "description": "Resume 버튼 클릭 시 이전에 저장된 상태(Focus/Break)로 복구하고 카운트다운을 재개하는 핸들러 구현",
            "dependencies": [
              1
            ],
            "details": "handleResumeClick 함수를 구현하여 저장된 previousState를 읽어 state에 복원하고, remainingTime을 유지하며, 카운트다운 재개 신호를 발생시킨다. 상태 복구 후 LocalStorage를 업데이트하여 동기화한다.",
            "status": "pending",
            "testStrategy": "Resume 상태 복구 테스트: Pause 상태에서 Resume 버튼 클릭 후 이전 상태(Focus/Break)로 올바르게 복구되는지 확인, remainingTime이 유지되는지 검증, 카운트다운이 재개되는지 확인",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Pause/Resume 핸들러에서 상태 저장 로직 통합",
            "description": "Pause/Resume 핸들러에서 상태 변경 후 LocalStorage/SessionStorage에 동기화하는 저장 로직을 구현하여 상태 일관성 보장",
            "dependencies": [
              1,
              2
            ],
            "details": "saveState 유틸리티 함수를 작성하여 현재 state, previousState, remainingTime, isPaused 플래그를 LocalStorage에 저장한다. Pause 핸들러에서 상태 전환 후 호출하고, Resume 핸들러에서 상태 복구 후 호출한다. 저장 실패 시 콘솔 에러 로깅을 추가한다.",
            "status": "pending",
            "testStrategy": "상태 저장 동기화 테스트: Pause/Resume 클릭 후 LocalStorage에 올바른 데이터가 저장되었는지 확인, 여러 번의 Pause/Resume 이후 최신 상태가 저장되는지 검증",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "디바운싱/쓰로틀링 적용으로 중복 클릭 방지",
            "description": "Pause/Resume 버튼 클릭 핸들러에 디바운싱 또는 쓰로틀링을 적용하여 짧은 시간 내 중복 클릭으로 인한 중복 상태 전환 방지",
            "dependencies": [
              1,
              2
            ],
            "details": "debounce 또는 throttle 유틸리티 함수를 구현하거나 라이브러리를 활용하여 handlePauseClick과 handleResumeClick을 래핑한다. 300-500ms의 대기 시간을 설정하여 연속 클릭을 무시한다. isProcessing 플래그로 상태 전환 중 중복 클릭을 차단하는 방식도 함께 고려한다.",
            "status": "pending",
            "testStrategy": "중복 클릭 방지 테스트: Pause 버튼을 50ms 간격으로 3회 빠르게 클릭 후 상태 전환이 1회만 발생했는지 확인, 디바운싱 대기 시간 초과 후 클릭은 정상 작동하는지 검증",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "버튼 비활성화 상태 관리 구현",
            "description": "Pause/Resume 버튼의 disabled 속성을 동적으로 관리하여 상태 전환 중에 중복 클릭을 UI 레벨에서 방지",
            "dependencies": [
              1,
              2
            ],
            "details": "isTransitioning 상태 변수를 추가하여 상태 전환 시 true로 설정하고, 전환 완료 후 false로 복원한다. Pause/Resume 버튼의 disabled={isTransitioning} 속성으로 연결하며, disabled 상태일 때 opacity 감소, cursor: not-allowed 스타일을 적용한다. 상태 전환 애니메이션이 있다면 애니메이션 완료 후 복원한다.",
            "status": "pending",
            "testStrategy": "버튼 비활성화 테스트: Pause 버튼 클릭 직후 Resume 버튼이 disabled 상태인지 확인, UI에서 비활성화 시각 표시(opacity/cursor)가 적용되었는지 검증, 상태 전환 완료 후 버튼이 활성화되는지 확인",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Skip/Reset 핸들러와의 상호작용 확인 및 통합",
            "description": "기존 Skip/Reset 핸들러와 Pause/Resume 핸들러의 상호작용을 검토하여 상충 없이 안전하게 통합하는 로직 구현",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Skip 클릭 시 현재 Pause 상태 여부 확인 후 처리 로직 정의: Pause 상태에서 Skip하면 카운트다운을 재개하지 않고 직접 다음 세션으로 전환할지, 아니면 Pause 해제 후 Skip할지 결정한다. Reset 클릭 시도 동일하게 검토한다. 상충 시나리오(Pause → Skip → Resume 시 상태 불일치) 테스트를 작성하고, previousState 초기화, 타이머 정리 로직을 추가하여 안정성을 높인다.",
            "status": "pending",
            "testStrategy": "상호작용 테스트: Pause 상태에서 Skip 버튼 클릭 후 다음 세션으로 올바르게 전환되는지 확인, Pause 상태에서 Reset 클릭 후 초기 상태로 복구되는지 검증, Skip/Reset 후 Resume 버튼이 의도치 않게 작동하지 않는지 확인",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 6,
        "expansionPrompt": "이벤트 핸들러 구현을 다음으로 세분화하세요: (1) Pause 버튼 클릭 핸들러(상태 전환, 시간 저장), (2) Resume 버튼 클릭 핸들러(상태 복구, 카운트다운 재개), (3) 상태 저장 로직 통합(localStorage), (4) 디바운싱/쓰로틀링으로 중복 클릭 방지, (5) 버튼 비활성화 상태 관리, (6) Skip/Reset 핸들러와의 상호작용 확인",
        "updatedAt": "2025-12-24T11:32:51.580Z"
      },
      {
        "id": "6",
        "title": "페이지 새로고침 시 Pause 상태 복구 로직 구현",
        "description": "저장된 Pause 상태 데이터를 읽어 페이지 새로고침 후에도 일관되게 복구하는 로직 구현",
        "details": "- 페이지 로드 시 저장된 상태 읽기: currentState, remainingTime, isPaused 플래그\n- isPaused === true인 경우: 상태를 Pause로 설정하고 카운트다운 시작하지 않음\n- 저장된 remainingTime을 UI에 표시\n- 타임스탬프 기반 검증: 새로고침 사이의 경과 시간 계산 (선택사항, 부정행위 방지)\n- 저장된 데이터가 없거나 손상된 경우의 폴백 (기본 상태로 초기화)\n- 기존 저장 정책(세션 복구)과 통합",
        "testStrategy": "저장/복구 테스트 (Pause 상태에서 페이지 새로고침 후 상태 확인, remainingTime 일치 검증, 저장 데이터 손상 시 폴백 작동)",
        "priority": "high",
        "dependencies": [
          "5"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "저장된 Pause 상태 데이터 읽기 구현",
            "description": "페이지 로드 시 LocalStorage/SessionStorage에서 currentState, remainingTime, isPaused 플래그를 읽어오는 로직 구현",
            "dependencies": [],
            "details": "저장소에서 JSON 형식의 상태 데이터를 파싱하고, 필수 필드(currentState, remainingTime, isPaused)가 존재하는지 검증하는 단계입니다. 데이터 타입 검증(remainingTime이 숫자인지 확인)을 포함하여 초기 읽기 로직을 구현합니다.",
            "status": "pending",
            "testStrategy": "저장된 상태 데이터가 정상적으로 로드되는지 확인, 필수 필드 존재 여부 검증, 잘못된 JSON 파싱 시 오류 처리 확인",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "isPaused 플래그 기반 Pause 상태 복구 로직",
            "description": "읽은 데이터에서 isPaused === true인 경우 타이머 상태를 Pause로 설정하고 카운트다운을 시작하지 않도록 구현",
            "dependencies": [
              1
            ],
            "details": "페이지 초기화 시 상태 머신에 Pause 상태를 명시적으로 설정하고, 카운트다운 인터벌이 시작되지 않도록 플래그 검사를 추가합니다. 기존 타이머 초기화 로직과 통합하여 중복 실행을 방지합니다.",
            "status": "pending",
            "testStrategy": "isPaused=true로 저장된 상태 복구 후 타이머가 시작되지 않는지 확인, 상태가 정확히 Pause로 설정되었는지 검증",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "저장된 remainingTime을 UI에 즉시 표시",
            "description": "복구된 remainingTime 값을 화면의 타이머 디스플레이에 바로 반영하여 사용자에게 보여주는 구현",
            "dependencies": [
              1
            ],
            "details": "타이머 UI 컴포넌트(분:초 포맷)에 복구된 remainingTime을 포맷팅하여 렌더링합니다. mm:ss 형식으로 변환하고, 음수나 비정상 값에 대한 경계 처리를 포함합니다.",
            "status": "pending",
            "testStrategy": "복구된 remainingTime이 올바른 형식(mm:ss)으로 표시되는지 확인, 다양한 시간값(00:05, 15:30, 59:59) 포맷팅 검증",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "타임스탬프 기반 경과 시간 검증 로직 구현 (선택사항)",
            "description": "페이지 새로고침 사이의 경과 시간을 계산하고, 비정상적인 시간 차이를 감지하는 부정행위 방지 로직",
            "dependencies": [
              1
            ],
            "details": "저장된 데이터에 타임스탬프를 포함시키고, 현재 시간과의 차이를 계산합니다. remainingTime과 실제 경과 시간의 불일치 감지 시 경고 로그를 남기고, 필요시 검증 실패 처리합니다. 시스템 시간 변조 또는 장시간 경과 감지에 활용됩니다.",
            "status": "pending",
            "testStrategy": "정상 경과 시간에서 검증 통과 확인, 비정상적인 시간 차이(음수, 과도한 시간) 감지 및 처리 검증",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "저장 데이터 손상/부재 시 폴백 로직 구현",
            "description": "저장된 데이터가 없거나 손상된 경우 기본 상태로 초기화하는 폴백 로직 구현",
            "dependencies": [
              1
            ],
            "details": "JSON 파싱 실패, 필수 필드 누락, 타입 오류 등의 예외 상황을 처리합니다. 폴백 시 currentState를 기본값(예: Focus)으로, remainingTime을 초기 세션 길이로, isPaused를 false로 설정하여 안정적인 상태로 복구합니다. 에러 로깅도 포함합니다.",
            "status": "pending",
            "testStrategy": "저장 데이터 없을 때 기본값으로 초기화 확인, 손상된 JSON 파싱 시 폴백 동작 검증, 필드 누락 시 올바른 기본값 적용 확인",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "기존 세션 복구 로직과의 통합 검증",
            "description": "새로 구현된 Pause 상태 복구 로직이 기존 세션 복구 메커니즘과 일관되게 작동하도록 통합하고 테스트",
            "dependencies": [
              2,
              3,
              4,
              5
            ],
            "details": "기존 세션 복구 로직(Task 1 분석 결과)과 충돌하지 않도록 통합합니다. 저장 정책의 우선순위 확인(SessionStorage vs LocalStorage), 여러 종류의 상태 데이터 동시 복구 시 처리 순서 정의, 기존 통계 복구와의 조합 시나리오 테스트를 포함합니다.",
            "status": "pending",
            "testStrategy": "Pause 상태 복구와 기존 통계 복구가 동시에 작동하는지 확인, 저장 데이터 우선순위 검증, 전체 세션 복구 시나리오(Pause/통계/세션 수) 통합 테스트",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 6,
        "expansionPrompt": "페이지 복구 로직을 다음으로 나누세요: (1) 저장된 Pause 상태 데이터 읽기(localStorage), (2) isPaused 플래그 기반 Pause 상태 복구, (3) remainingTime UI 표시, (4) 타임스탬프 기반 경과 시간 검증(선택사항), (5) 저장 데이터 손상/부재 시 폴백, (6) 기존 세션 복구 로직과의 통합",
        "updatedAt": "2025-12-24T11:36:02.004Z"
      },
      {
        "id": "7",
        "title": "Pause 상태에서 Skip/Reset 동작 구현 및 통계 정책 유지",
        "description": "Pause 중에 Skip 또는 Reset을 누르면 즉시 다음 상태로 전환하고, 기존 통계 변경 규칙을 정확히 적용",
        "details": "- Skip (건너뛰기) 로직: Pause 상태 → Focus/Break 완료 처리 → 다음 세션으로 전환\n  - Skip 시 완료 세션 카운트 증가 여부 확인 (기존 정책대로)\n  - 누적 포커스 시간 계산: Pause 상태이므로 추가 시간 증가 없음\n- Reset (초기화) 로직: Pause 상태 → 현재 세션 초기 시간으로 복구\n  - Reset 시 세션 카운트, 완료 세션 카운트 변화 없음 (기존 정책)\n- Skip/Reset 클릭 시 즉시 상태 전환 (Pause 상태 건너뜀)\n- 통계 테이블 확인 (세션 수, 완료 세션 수, 누적 포커스 시간이 정책대로 계산되는지)",
        "testStrategy": "Skip/Reset 테스트 (Pause 중 Skip 클릭 후 다음 세션 진입, 통계 변경 규칙 적용 확인, Reset 클릭 후 세션 시간 복구 확인)",
        "priority": "high",
        "dependencies": [
          "6"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Pause 상태에서 Skip 로직 구현",
            "description": "Pause 상태에서 Skip 버튼 클릭 시 Focus/Break 완료 처리 후 다음 세션으로 즉시 전환하는 로직을 구현하고, 기존 완료 세션 카운트 정책을 적용합니다.",
            "dependencies": [],
            "details": "Skip 핸들러에서 Pause 상태 체크 → 현재 세션을 완료 상태로 표기 → 다음 세션 유형 결정(Focus/Short Break/Long Break) → 세션 전환 실행. 완료 세션 카운트 증가 규칙(Focus 완료 시만 증가)을 정확히 적용하고, Pause 상태에서는 누적 포커스 시간이 증가하지 않음을 보장.",
            "status": "pending",
            "testStrategy": "Pause 상태에서 Skip 클릭 후 다음 세션 진입 확인, 완료 세션 카운트 변경 규칙 검증, 누적 포커스 시간 미변경 확인",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Pause 상태에서 Reset 로직 구현",
            "description": "Pause 상태에서 Reset 버튼 클릭 시 현재 세션의 시간을 초기값으로 복구하고, 세션 카운트와 완료 세션 카운트는 변경하지 않도록 구현합니다.",
            "dependencies": [],
            "details": "Reset 핸들러에서 Pause 상태 체크 → 현재 세션의 남은 시간을 원래 설정값(25분/5분/15분)으로 복구 → 타이머 상태 업데이트. 세션 카운트, 완료 세션 카운트, 누적 포커스 시간은 어떠한 경우에도 변경되지 않음을 확인.",
            "status": "pending",
            "testStrategy": "Pause 상태에서 Reset 클릭 후 세션 시간 초기값 복구 확인, 모든 통계 수치 미변경 검증",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Skip/Reset 클릭 시 Pause 상태 즉시 건너뛰기 구현",
            "description": "Skip 또는 Reset 버튼 클릭 시 Pause 상태를 거치지 않고 즉시 다음 상태(또는 복구된 상태)로 전환하여 중간 상태 대기 시간을 제거합니다.",
            "dependencies": [
              1,
              2
            ],
            "details": "Skip/Reset 핸들러에서 상태 전환 로직을 직접 실행하여 Pause 상태를 우회. 예를 들어 Skip 시 세션 완료 처리 후 바로 다음 세션 진입, Reset 시 타이머 값만 복구하고 Pause 상태 유지. UI에서 상태 업데이트가 동기적으로 반영되도록 구현.",
            "status": "pending",
            "testStrategy": "Skip/Reset 후 상태 전환이 즉시 발생하는지 UI에서 확인, Pause 상태 중간 단계 없음 검증",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "00:00 도달 직전 중복 완료 방지 플래그 강화",
            "description": "00:00에 가까운 시점에서 Pause/Resume을 연타할 때 세션 완료가 중복되지 않도록 isSessionComplete 플래그를 도입하고 안전 장치를 구현합니다.",
            "dependencies": [
              1
            ],
            "details": "세션 상태에 isSessionComplete 플래그 추가. 카운트다운이 00:00에 도달했을 때 이 플래그를 체크하여 이미 완료 처리됐으면 return. 완료 처리(통계 업데이트, 세션 전환 등) 후 플래그를 true로 설정. Pause/Resume 중에는 이 플래그가 수정되지 않도록 보호. 00:00에서 타이머 인터벌을 정지하여 추가 카운트다운 실행 방지.",
            "status": "pending",
            "testStrategy": "00:01 상태에서 Pause/Resume 빠른 연타, 00:00 도달 후 완료 처리가 정확히 1회만 실행되는지 확인, 통계 수치 중복 증가 방지 검증",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Pause 중 누적 포커스 시간 증가 방지 검증",
            "description": "Pause 상태에서는 시간이 경과해도 누적 포커스 시간이 증가하지 않도록 구현하고, 이 규칙이 일관되게 적용되는지 전체 로직에서 검증합니다.",
            "dependencies": [
              1,
              2
            ],
            "details": "Pause 상태의 타이머 인터벌은 실행되지 않도록 구현(clearInterval 또는 조건 체크). Resume 시 인터벌 재시작. 누적 포커스 시간 계산 로직에서 Focus 세션이 00:00에 도달할 때만 증가하는 규칙 확인. 다양한 시나리오(Focus 중간 Pause, Pause 중 Skip/Reset 등)에서 시간 증가 없음을 테스트.",
            "status": "pending",
            "testStrategy": "Pause 상태 지속 중 누적 포커스 시간 값 변경 없음 확인, 통계 테이블에서 시간 미증가 검증, 여러 번 Pause/Resume 반복 후에도 일관성 유지 확인",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "통계 테이블에서 Skip/Reset 정책 적용 결과 검증",
            "description": "대시보드 또는 통계 화면에서 세션 수, 완료 세션 수, 누적 포커스 시간이 Skip/Reset 정책에 따라 정확히 계산되는지 UI 수준에서 검증합니다.",
            "dependencies": [
              1,
              2,
              3,
              5
            ],
            "details": "통계 화면을 열어 현재 세션 수(Focus 시작 시 증가), 완료 세션 수(Focus 00:00 도달 시 증가), 누적 포커스 시간(Focus 완료 시만 증가) 확인. Skip 시나리오: 완료 세션 증가 여부 확인. Reset 시나리오: 모든 통계 수치 변경 없음 확인. Pause/Resume 반복 후 통계 계산 결과가 예상값과 일치하는지 비교.",
            "status": "pending",
            "testStrategy": "UI 통계 화면에서 세션/완료/누적시간 수치 시각적 확인, Skip/Reset 각 시나리오별 통계 변경 규칙 검증, 기대값과 실제값 일치 확인",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "빌드/린트/테스트 실행 및 최종 배포 준비",
            "description": "모든 Skip/Reset/Pause 로직 구현 완료 후 pnpm lint, pnpm build, pnpm test를 실행하여 코드 품질과 기능 정합성을 검증하고 배포 준비를 완료합니다.",
            "dependencies": [
              1,
              2,
              3,
              4,
              5,
              6
            ],
            "details": "pnpm lint 실행: 코드 스타일, 미사용 변수, 타입 오류 확인. pnpm build 실행: 번들 생성 및 빌드 오류 확인. pnpm test 실행(테스트 파일 존재 시): 모든 유닛/통합 테스트 통과 확인. 린트 경고/오류 모두 해결. 빌드 경고 최소화. 테스트 커버리지 확인. 커밋 메시지는 한국어로 작성.",
            "status": "pending",
            "testStrategy": "자동화된 빌드/린트/테스트 파이프라인 전체 실행, 모든 오류/경고 해결, 테스트 통과율 100% 확인, 배포 준비 완료 확인",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 7,
        "expansionPrompt": "Skip/Reset 동작을 다음으로 나누세요: (1) Pause 상태에서 Skip 로직(완료 처리 후 다음 세션), (2) Pause 상태에서 Reset 로직(세션 초기화), (3) Skip/Reset 시 Pause 상태 즉시 건너뛰기, (4) 00:00 중복 완료 방지 플래그 강화, (5) Pause 중 누적 포커스 시간 증가 방지 검증, (6) 통계 테이블에서 정책 적용 검증, (7) 빌드/린트/테스트 실행",
        "updatedAt": "2025-12-24T11:40:58.779Z"
      },
      {
        "id": "8",
        "title": "00:00 도달 직전 Pause/Resume 연타 시 중복 완료 방지 로직 강화",
        "description": "엣지 케이스: 00:00에 가까운 시점에서 Pause/Resume을 빠르게 연타할 때 세션 완료가 중복되지 않도록 안전 장치 구현",
        "details": "- 세션 완료 처리 플래그 추가: isSessionComplete = false\n- 카운트다운에서 00:00 도달 시 플래그 체크: if (isSessionComplete) return; // 중복 완료 방지\n- 완료 처리 수행 후 플래그 = true 설정\n- Pause/Resume 중에는 이 플래그 수정 불가\n- Resume 후 카운트다운 재개 시 플래그 상태 검증\n- 00:00에서 타이머 인터벌 정지 (더 이상 카운트다운 루프 실행 안 함)\n- 기존 완료 로직(세션 전환, 통계 업데이트)에 이 플래그 삽입",
        "testStrategy": "엣지 케이스 테스트 (00:01에서 Pause/Resume 연타, 00:00 도달 후 완료 처리 1회만 수행 확인, 통계 중복 증가 방지 검증)",
        "priority": "high",
        "dependencies": [
          "3",
          "7"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "isSessionComplete 플래그 추가 및 초기화",
            "description": "세션 완료 처리 플래그를 타이머 상태 관리에 추가하고 초기값을 false로 설정",
            "dependencies": [],
            "details": "타이머 상태 객체에 isSessionComplete 속성을 추가하고, 세션 시작 시 항상 false로 초기화하는 로직 구현. 상태 저장(LocalStorage/SessionStorage)에도 이 플래그 포함",
            "status": "pending",
            "testStrategy": "상태 초기화 테스트: 새로운 세션 시작 시 isSessionComplete가 false로 설정되는지 확인, 저장된 상태 로드 시 플래그 값 복원 확인",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "카운트다운 루프에서 00:00 도달 시 플래그 체크 로직 추가",
            "description": "카운트다운이 00:00에 도달했을 때 isSessionComplete 플래그를 검사하여 중복 완료 처리 방지",
            "dependencies": [
              1
            ],
            "details": "기존 카운트다운 완료 처리 코드 앞에 if (isSessionComplete) return; 조건문을 추가. remainingTime <= 0 도달 시 먼저 플래그 상태를 확인한 후 완료 로직 실행 여부 결정",
            "status": "pending",
            "testStrategy": "중복 방지 테스트: 00:00 도달 후 완료 로직이 정확히 1회만 실행되는지 확인, 플래그가 true인 경우 완료 로직 스킵 동작 검증",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "완료 처리 수행 후 isSessionComplete 플래그를 true로 설정",
            "description": "세션 완료 처리(세션 전환, 통계 업데이트) 수행 직후 플래그를 true로 변경하여 이후 완료 처리 방지",
            "dependencies": [
              2
            ],
            "details": "기존 세션 완료 로직(세션 전환, 통계 업데이트 등) 실행 후에 isSessionComplete = true를 설정. 완료 후 상태를 저장하여 페이지 새로고침 후에도 플래그 상태 유지",
            "status": "pending",
            "testStrategy": "플래그 설정 테스트: 완료 로직 실행 후 isSessionComplete가 true로 변경되는지 확인, 저장된 상태에 플래그 값이 포함되는지 검증",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Pause/Resume 중 플래그 수정 불가 규칙 정의 및 구현",
            "description": "Pause 또는 Resume 상태 전환 중에는 isSessionComplete 플래그가 의도하지 않게 변경되지 않도록 보호",
            "dependencies": [
              1
            ],
            "details": "Pause 버튼 핸들러와 Resume 버튼 핸들러에서 isSessionComplete 플래그를 읽기만 하고 수정하지 않도록 코드 구조화. 플래그는 00:00 도달 완료 처리 시에만 변경되도록 제한",
            "status": "pending",
            "testStrategy": "보호 규칙 테스트: Pause/Resume 중에 플래그 값이 변경되지 않음을 확인, 플래그 상태에 따른 조건부 동작 검증",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Resume 후 카운트다운 재개 시 플래그 상태 검증",
            "description": "Resume으로 카운트다운을 재개할 때 isSessionComplete 플래그 상태를 확인하여 이미 완료된 세션은 재개하지 않도록 검증",
            "dependencies": [
              3
            ],
            "details": "Resume 핸들러에서 카운트다운 재개 전에 isSessionComplete 값을 체크. true인 경우 카운트다운을 시작하지 않고 완료 상태 유지. remainingTime <= 0인 경우도 함께 검증하여 일관성 유지",
            "status": "pending",
            "testStrategy": "Resume 검증 테스트: 완료된 세션에서 Resume 클릭 시 카운트다운이 재개되지 않는지 확인, 플래그 상태와 남은 시간 일관성 검증",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "00:00 도달 시 타이머 인터벌 정지 구현",
            "description": "00:00에 도달했을 때 setInterval 타이머를 명시적으로 정지하여 더 이상의 카운트다운 루프 실행 방지",
            "dependencies": [
              2,
              3
            ],
            "details": "기존 완료 처리 로직에 clearInterval(timerId) 또는 타이머 정지 메서드 호출 추가. 인터벌이 계속 실행되지 않도록 정리하여 불필요한 상태 확인 루프 제거",
            "status": "pending",
            "testStrategy": "인터벌 정지 테스트: 00:00 도달 후 타이머 인터벌이 정지되는지 확인, 정지 후 추가 카운트다운이 실행되지 않음을 검증",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "00:01에서의 연타 테스트로 중복 완료 및 통계 오류 방지 검증",
            "description": "엣지 케이스: 00:01에서 Pause/Resume을 빠르게 연타하여 중복 완료 및 통계 오류가 발생하지 않음을 확인하는 통합 테스트",
            "dependencies": [
              1,
              2,
              3,
              4,
              5,
              6
            ],
            "details": "00:01 상태에서 Pause/Resume을 10회 이상 연타하는 시뮬레이션 테스트 작성. 완료 처리 횟수, 통계 업데이트 횟수, 최종 세션 상태, 저장된 데이터 일관성을 검증. 경쟁 상태(race condition) 방지 확인",
            "status": "pending",
            "testStrategy": "엣지 케이스 통합 테스트: Pause/Resume 연타 시뮬레이션 (최소 10회), 완료 로직 1회만 실행 확인, 통계 중복 증가 방지 검증, 최종 상태와 저장 데이터 일치도 확인",
            "parentId": "undefined"
          }
        ],
        "complexity": 8,
        "recommendedSubtasks": 7,
        "expansionPrompt": "중복 완료 방지를 다음으로 세분화하세요: (1) isSessionComplete 플래그 추가 및 초기화, (2) 카운트다운 루프에서 00:00 도달 시 플래그 체크, (3) 완료 처리 후 플래그 true 설정, (4) Pause/Resume 중 플래그 수정 불가 규칙, (5) Resume 후 카운트다운 재개 시 플래그 검증, (6) 00:00 도달 시 타이머 인터벌 정지, (7) 00:01에서의 연타 테스트로 검증",
        "updatedAt": "2025-12-24T11:44:35.858Z"
      },
      {
        "id": "9",
        "title": "기존 통계 계산 로직 검증 및 Pause 통합 테스트",
        "description": "Pause 기능 추가 후 기존 통계(세션 증가, 완료 세션, 누적 포커스 시간) 계산이 정책대로 유지되는지 전체 검증",
        "details": "- 세션 증가 규칙: Focus 세션 시작 시 1 증가 (Pause/Resume은 변화 없음)\n- 완료 세션 증가: Focus 세션 00:00 도달 시 1 증가 (Pause 중 건너뛰기는 정책 확인)\n- 누적 포커스 시간: Focus 세션 00:00 도달 시만 증가 (Pause 중 시간 경과 없음)\n- 통계 UI 검증: 대시보드/통계 화면에서 올바른 수치 표시\n- 다양한 시나리오 테스트:\n  1) Focus 완료\n  2) Focus Pause 후 Resume 완료\n  3) Focus Pause 후 Skip\n  4) Focus Pause 후 Reset\n  5) 여러 번 Pause/Resume 반복 후 완료\n- 기존 테스트 스위트 모두 통과 확인",
        "testStrategy": "통계 시뮬레이션 테스트 (각 시나리오별 세션/완료 세션/누적 시간 계산 검증, 대시보드 수치 확인, 기존 테스트 스위트 통과)",
        "priority": "high",
        "dependencies": [
          "8"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "통계 계산 규칙 검증 테스트 환경 구성",
            "description": "세션 증가, 완료 세션, 누적 포커스 시간 계산 검증을 위한 테스트 틀 및 모의 데이터 환경 구성",
            "dependencies": [],
            "details": "테스트 파일 생성(테스트 프레임워크 선택: Jest/Vitest), 각 통계 규칙별 단위 테스트 케이스 작성, 모의 타이머 및 상태 값 설정, 통계 계산 함수 검증용 헬퍼 함수 작성, 기초 테스트 데이터 셋업(Focus 세션 초기 상태, 다양한 카운트다운 값, Pause/Resume 시나리오별 초기 상태)",
            "status": "pending",
            "testStrategy": "테스트 파일 생성 및 실행 가능성 확인, 모의 데이터 정상 로드 검증",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "세션 증가 규칙 검증 (Focus 시작 시만 증가)",
            "description": "Focus 세션 시작 시에만 세션 카운트가 1 증가하고, Pause/Resume 중에는 변화가 없는지 검증",
            "dependencies": [
              1
            ],
            "details": "Focus 세션 시작 시 세션 증가 테스트, Pause 상태 진입 시 세션 카운트 불변 검증, Resume 수행 후 세션 카운트 불변 검증, 여러 번 Pause/Resume 반복 후에도 세션 카운트 불변 검증, 세션 초기화 후 다시 시작 시 정확히 1 증가 확인",
            "status": "pending",
            "testStrategy": "각 상태 전환에서 세션 카운트 값 비교 검증, 예상 값과 실제 값 일치 확인",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "완료 세션 증가 규칙 검증 (00:00 도달 시만 증가)",
            "description": "Focus 세션이 00:00에 도달할 때만 완료 세션 카운트가 1 증가하고, Pause 상태나 Skip/Reset 시에는 변화가 없는지 검증",
            "dependencies": [
              1
            ],
            "details": "Focus 세션이 00:00 도달 시 완료 세션 증가 테스트, Pause 상태에서 Skip 수행 시 완료 세션 불변 검증, Pause 상태에서 Reset 수행 시 완료 세션 불변 검증, Pause->Resume->완료 시나리오에서 정확히 1 증가 검증, 누적 완료 세션 수가 올바르게 계산되는지 확인",
            "status": "pending",
            "testStrategy": "각 시나리오별 완료 세션 카운트 값 검증, Pause 중 Skip/Reset에서 카운트 불변 확인, 00:00 도달 시에만 증가 확인",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "누적 포커스 시간 계산 검증 (00:00 시만 증가)",
            "description": "Focus 세션이 00:00에 도달할 때만 누적 포커스 시간이 증가하고, Pause 중 시간 경과는 없는지 검증",
            "dependencies": [
              1
            ],
            "details": "Focus 세션 00:00 도달 시 누적 포커스 시간 증가(설정된 Focus 시간만큼) 검증, Pause 상태에서 시간 경과 없음(누적 시간 불변) 검증, Pause->Resume->완료 시나리오에서 누적 시간 정확히 증가 검증, 여러 세션 반복 후 누적 시간 누적 합계 검증, Pause 중 Skip/Reset 시 누적 시간 불변 검증",
            "status": "pending",
            "testStrategy": "초기 누적 시간과 각 이벤트 후 누적 시간 비교, Pause 상태 진입/복귀 전후 시간 변화 없음 확인, 완료 시점에서만 증가 검증",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "5가지 주요 시나리오별 통계 자동 검증",
            "description": "Focus 완료, Pause->Resume 완료, Pause->Skip, Pause->Reset, 다중 Pause/Resume 반복의 5가지 시나리오에서 통계 값이 정책에 맞는지 자동 검증",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "시나리오 1: Focus 완료 - 세션+1, 완료+1, 누적시간+설정시간 검증 / 시나리오 2: Pause->Resume->완료 - 동일 검증 / 시나리오 3: Pause->Skip - 세션+1, 완료 무변화, 누적시간 무변화 검증 / 시나리오 4: Pause->Reset - 세션 무변화, 완료/누적시간 무변화 검증 / 시나리오 5: 다중 Pause/Resume 반복->완료 - 모든 통계 1회만 증가 검증",
            "status": "pending",
            "testStrategy": "각 시나리오 테스트 케이스 작성, 예상 통계 값 정의 및 검증, 통합 로그 출력으로 상태 추적",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "통계 UI 검증 (대시보드에서 올바른 수치 표시)",
            "description": "계산된 통계 값이 대시보드 및 통계 화면에서 올바르게 렌더링되는지 시각적으로 검증",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "대시보드에서 세션 카운트 표시 검증(숫자, 포맷 정확성), 완료 세션 카운트 표시 검증, 누적 포커스 시간 표시 검증(시간:분:초 포맷), 통계 화면에서 상세 통계 렌더링 검증, 상태 변경 후 UI 업데이트 타이밍 검증(즉시 반영 확인), 시나리오 5개별 각각 수행 후 UI 수치 일치 확인",
            "status": "pending",
            "testStrategy": "DOM 요소 선택 및 텍스트 값 검증, 각 통계 UI 컴포넌트 값 확인, 시나리오별 UI 업데이트 검증",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "기존 테스트 스위트 전체 통과 및 회귀 테스트",
            "description": "Pause 기능 추가로 인한 기존 기능 영향이 없는지 확인하고 모든 기존 테스트가 통과하는지 검증",
            "dependencies": [
              5,
              6
            ],
            "details": "pnpm test 실행 및 모든 유닛 테스트 통과 확인, pnpm test 실행 및 모든 통합 테스트 통과 확인, 기존 Focus/Break 상태 전환 로직 검증(Pause 추가 전과 동일 동작), 기존 Skip/Reset 기능 검증(Pause 상태가 아닐 때 정상 작동), 기존 통계 계산이 Pause 없이 수행되는 시나리오에서 정상 작동 검증, 회귀 테스트 결과 문서화",
            "status": "pending",
            "testStrategy": "전체 테스트 스위트 실행 및 패스율 100% 확인, 회귀 테스트 케이스 작성 및 실행",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "최종 통합 테스트 결과 정리 및 품질 게이트 확인",
            "description": "모든 통계 검증 테스트 완료 후 pnpm lint, pnpm build 실행으로 최종 코드 품질을 확인하고 배포 준비 완료 확인",
            "dependencies": [
              7
            ],
            "details": "pnpm lint 실행: 코드 스타일, 미사용 변수, 타입 오류 없음 확인, pnpm build 실행: 번들 생성 및 빌드 오류 없음 확인, 모든 테스트 결과 요약 및 이슈 목록 정리, 성능 영향 평가(Pause/Resume 반복 시 메모리 누수/성능 저하 없음), 최종 코드 리뷰 수행(주석/문서화 확인), 통합 테스트 최종 결과 보고서 작성, 배포 체크리스트 완료",
            "status": "pending",
            "testStrategy": "lint/build 자동화 파이프라인 실행, 모든 오류/경고 해결, 성능 프로파일링 수행, 최종 검증 체크리스트 완료",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 8,
        "expansionPrompt": "통계 검증을 다음으로 나누세요: (1) 통계 계산 규칙 검증 테스트 환경 구성, (2) 세션 증가 규칙 검증(Focus 시작 시만), (3) 완료 세션 증가 규칙 검증(00:00 도달 시만), (4) 누적 포커스 시간 계산 검증(00:00 시만), (5) 5가지 주요 시나리오별 통계 자동 검증, (6) 통계 UI 검증(대시보드), (7) 기존 테스트 스위트 전체 통과, (8) 최종 통합 테스트 결과 정리 및 품질 게이트",
        "updatedAt": "2025-12-24T11:46:24.439Z"
      },
      {
        "id": "10",
        "title": "빌드/린트/테스트 실행 및 최종 검증",
        "description": "Pause 기능 완성 후 빌드, 린트, 테스트를 실행하여 코드 품질과 기능 정합성을 최종 검증",
        "details": "- pnpm lint 실행: 코드 스타일, 미사용 변수, 타입 오류 확인\n- pnpm build 실행: 번들 생성 및 빌드 오류 확인\n- pnpm test 실행 (테스트 파일 있는 경우): 모든 유닛/통합 테스트 통과 확인\n- E2E 테스트 추가 (선택사항): Pause/Resume UI 흐름 검증\n- 브라우저 호환성 확인 (주요 브라우저에서 타이머/Pause 동작)\n- 성능 프로파일링: Pause/Resume 반복 시 메모리 누수/성능 저하 없음\n- 최종 코드 리뷰: 주석/문서화 확인",
        "testStrategy": "자동화된 빌드/린트/테스트 파이프라인 실행, 모든 오류/경고 해결, E2E 테스트 시나리오 검증, 최종 배포 준비 확인",
        "priority": "high",
        "dependencies": [
          "9"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "pnpm lint 실행 및 코드 스타일 오류 수정",
            "description": "pnpm lint를 실행하여 코드 스타일, 미사용 변수, 타입 오류를 식별하고 모든 린트 경고를 해결",
            "dependencies": [],
            "details": "pnpm lint 명령 실행 후 출력된 모든 오류와 경고를 검토하고, 각 카테고리별로 오류를 수정합니다. 특히 타입 오류, 미사용 변수, 일관되지 않은 코드 스타일을 수정하고, 최종적으로 lint 경고 0개 상태를 달성합니다.",
            "status": "pending",
            "testStrategy": "pnpm lint 재실행하여 경고/오류 0개 확인",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "pnpm build 실행 및 빌드 오류 해결",
            "description": "pnpm build를 실행하여 번들 생성 및 빌드 오류를 식별하고 모든 빌드 오류를 해결",
            "dependencies": [
              1
            ],
            "details": "pnpm build 명령 실행 후 빌드 프로세스를 모니터링합니다. 번들 생성 오류, 의존성 문제, 구성 오류 등을 식별하고 각각을 수정합니다. 최종적으로 빌드가 성공적으로 완료되고 번들이 생성되도록 합니다.",
            "status": "pending",
            "testStrategy": "pnpm build 재실행하여 빌드 완료 및 번들 생성 확인",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "pnpm test 실행 및 모든 테스트 케이스 통과",
            "description": "pnpm test를 실행하여 모든 유닛/통합 테스트가 통과하는지 확인하고 실패한 테스트를 수정",
            "dependencies": [
              2
            ],
            "details": "pnpm test 명령 실행 후 테스트 결과를 분석합니다. 실패한 테스트가 있는 경우 각 테스트의 실패 원인을 파악하고, Pause 기능 구현으로 인한 상태 머신 변경이 기존 테스트와 호환되는지 검증하며 필요한 수정을 수행합니다.",
            "status": "pending",
            "testStrategy": "pnpm test 재실행하여 모든 테스트 통과 확인 (실패율 0%)",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "E2E 테스트 추가: Pause/Resume UI 흐름 검증",
            "description": "Pause/Resume 기능의 사용자 인터페이스 흐름을 자동화된 E2E 테스트로 작성하여 실제 사용 시나리오 검증",
            "dependencies": [
              3
            ],
            "details": "E2E 테스트 프레임워크(Cypress, Playwright 등)를 사용하여 Pause/Resume UI 흐름을 테스트합니다. 테스트 시나리오: (1) Focus 상태에서 Pause 버튼 클릭, (2) Pause 상태에서 Resume 버튼 클릭, (3) Pause 중 Skip/Reset 버튼 동작, (4) Pause/Resume 반복 시 타이머 정확성, (5) 페이지 새로고침 후 Pause 상태 복구를 포함합니다.",
            "status": "pending",
            "testStrategy": "E2E 테스트 스크립트 작성 및 모든 UI 흐름 시나리오 통과 확인",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "주요 브라우저 호환성 테스트 (Chrome, Firefox, Safari)",
            "description": "Chrome, Firefox, Safari 등 주요 브라우저에서 타이머와 Pause 기능이 정상적으로 동작하는지 확인",
            "dependencies": [
              4
            ],
            "details": "각 주요 브라우저에서 다음을 검증합니다: (1) 타이머 카운트다운이 정상 동작, (2) Pause/Resume 버튼의 UI 반응성, (3) 상태 전환이 정확하게 이루어지는지, (4) LocalStorage/SessionStorage 상태 저장 및 복구 동작, (5) 브라우저 콘솔 오류 없음. 각 브라우저별 수동 테스트 또는 자동화된 크로스 브라우저 테스트 도구를 사용합니다.",
            "status": "pending",
            "testStrategy": "각 브라우저에서 수동 또는 자동 테스트 수행, 모든 브라우저에서 기능 정상 동작 확인",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "성능 프로파일링: 메모리 누수 및 성능 저하 검증",
            "description": "Pause/Resume을 반복 실행할 때 메모리 누수, 성능 저하, 불필요한 리렌더링이 없는지 검증",
            "dependencies": [
              5
            ],
            "details": "브라우저 개발자 도구(DevTools)의 성능 프로파일링 기능을 사용합니다: (1) Pause/Resume을 10회 이상 반복하며 메모리 사용량 모니터링, (2) CPU 사용률 확인, (3) 리렌더링 횟수 분석, (4) 이벤트 리스너 정리 확인 (메모리 누수 방지), (5) 타이머 인터벌이 정확하게 정리되는지 검증. 성능 저하나 메모리 누수 징후가 없음을 확인합니다.",
            "status": "pending",
            "testStrategy": "DevTools 성능 프로파일링으로 메모리 증가 추이 확인, 메모리 누수 없음 및 성능 기준 충족 검증",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "최종 코드 리뷰: 주석/문서화 및 코드 품질 검증",
            "description": "전체 Pause 기능 구현 코드를 리뷰하여 주석, 문서화, 코드 품질을 검증하고 최종 배포 준비 상태 확인",
            "dependencies": [
              6
            ],
            "details": "다음 항목들을 검토합니다: (1) Pause 관련 함수/메서드의 명확한 주석 및 JSDoc 문서화, (2) 상태 전환 로직의 가독성과 유지보수성, (3) 00:00 중복 완료 방지 로직의 안전성, (4) 통계 계산 로직이 정책을 준수하는지, (5) 불필요한 코드나 임시 디버그 코드 제거, (6) 일관된 변수명과 코드 스타일, (7) 에러 처리의 완전성. 최종적으로 배포 가능한 수준의 코드 품질을 확보합니다.",
            "status": "pending",
            "testStrategy": "코드 검토 체크리스트 작성 및 모든 항목 통과, 배포 준비 완료 상태 확인",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 7,
        "expansionPrompt": "최종 검증을 다음으로 나누세요: (1) pnpm lint 실행 및 오류 수정, (2) pnpm build 실행 및 빌드 오류 해결, (3) pnpm test 실행(테스트 존재 시), (4) E2E 테스트 추가(Pause/Resume UI 흐름), (5) 주요 브라우저 호환성 테스트, (6) 성능 프로파일링(메모리 누수/성능 저하), (7) 최종 코드 리뷰(주석/문서화)",
        "updatedAt": "2025-12-24T11:47:40.645Z"
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-12-24T14:19:07.602Z",
      "taskCount": 10,
      "completedCount": 10,
      "tags": [
        "master"
      ]
    }
  }
}